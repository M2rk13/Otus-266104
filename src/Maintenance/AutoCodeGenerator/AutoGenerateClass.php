<?php

declare(strict_types=1);

namespace App\Maintenance\AutoCodeGenerator;

use App\Exception\ProjectException;
use ReflectionClass;
use ReflectionException;
use ReflectionMethod;
use ReflectionParameter;
use App\Maintenance\Ioc\IoC;

class AutoGenerateClass implements AutoGenerateClassInterface
{
    private ReflectionClass $reflectionClass;

    /**
     * @param mixed $object
     * @param string $prefixClass
     * @throws ReflectionException
     */
    public function __construct(
        object | string $object,
        private readonly string $prefixClass = 'AutoGenerated',
    ) {
        $this->reflectionClass = new ReflectionClass($object);
    }

    public function getGeneratedClassBody(): string
    {
        $className = $this->prefixClass . $this->reflectionClass->getShortName();
        $useList = $this->getUseList();
        $methodList = $this->getMethodList();

        return sprintf(
            file_get_contents('src/Maintenance/AutoCodeGenerator/ClassTemplate'),
            $useList,
            $className,
            $methodList
        );
    }

    private function getUseList(): string
    {
        $reflectionClass = new ReflectionClass(IoC::class);
        $useList = [sprintf('use %s;', $reflectionClass->getName())];

        foreach ($this->reflectionClass->getMethods() as $method) {
            foreach ($method->getParameters() as $parameter) {
                $parameterType = $parameter->getType()?->getName();

                if (!empty($parameterType)) {
                    $useList[] = sprintf('use %s;', $parameterType);
                }
            }
        }

        return implode("\n", array_unique($useList));
    }

    private function getMethodList(): string
    {
        $methodList = [];

        foreach ($this->reflectionClass->getMethods() as $method) {
            $methodName = $method->getName();
            $methodNameWithParameters = sprintf('%s(%s)',$methodName, $this->getMethodParameterList($method));

            $methodAccessModifier = $this->getMethodAccessModifier($method);
            $methodReturnType = $this->getTypeName($method);

            $methodBody = sprintf(
                'return $this->ioC->resolve($this->object::class . \'%s\', $this->object);',
                $methodName
            );

            if (str_starts_with($method->getName(), 'set')) {
                $methodBody = sprintf(
                    '$this->ioC->resolve($this->object::class . \'%s\', $this->object, $newVector);',
                    $methodName
                );
            }

            $methodList[] =  sprintf(
                file_get_contents('src/Maintenance/AutoCodeGenerator/FunctionTemplate'),
                $methodAccessModifier,
                $methodNameWithParameters,
                $methodReturnType,
                $methodBody
            );
        }

        return implode("\n\n", $methodList);
    }

    private function getMethodAccessModifier(ReflectionMethod $method): string
    {
        return match (true) {
            $method->isPublic() => 'public',
            $method->isProtected() => 'protected',
            $method->isPrivate() => 'private',
            default => throw new ProjectException(sprintf(
                'unknown access modifier for method %s',
                $method->getName()
            )),
        };
    }

    private function getMethodParameterList(ReflectionMethod $method): string
    {
        $methodParameterList = [];

        foreach ($method->getParameters() as $parameter) {
            $methodParameterList[] = sprintf(
                '%s $%s',
                $this->getTypeName($parameter),
                $parameter->getName()
            );
        }

        return implode(', ', $methodParameterList);
    }

    private function getTypeName(ReflectionMethod | ReflectionParameter $object): string
    {
        $type = match (true) {
            $object instanceof ReflectionMethod => $object->getReturnType()?->getName(),
            $object instanceof ReflectionParameter => $object->getType()?->getName(),
        };

        if (empty($type)) {
            return 'mixed';
        }

        $type = explode('\\', $type);

        return array_pop($type);
    }
}
